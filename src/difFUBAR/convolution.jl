"""
This file contains code for applying Gaussian smoothing to multi-dimensional arrays in a way that works with automatic differentiation.
"""


"""
# apply_smoothing(grid_sizes::Tuple, ambient_parameters::AbstractVector{<:Real}, kernel_parameters::AbstractVector{<:Real})
Applies a Gaussian smoothing filter to the ambient parameters (with dimension equaling that of the probability vector).
The gaussian kernel used has variance specified by kernel_parameters[1]^2.
For this to work, the probability vector has to be indexed like con_lik_mat generated by difFUBAR_grid()
"""
function apply_smoothing(grid_sizes::Tuple, ambient_parameters::AbstractVector{<:Real}, kernel_parameters::AbstractVector{<:Real})
    ambient_parameter_array = reshape_probability_vector(grid_sizes, ambient_parameters)
    kernel = gaussian_kernel(5, kernel_parameters[1]^2) #approximate_gaussian_kernel(kernel_parameters[1]^2, 4)
    smoothed_parameter_array = apply_separable_convolution(ambient_parameter_array, kernel)
    return unreshape_probability_vector(grid_sizes, smoothed_parameter_array)
end

"""
# fubar_apply_smoothing(grid_sizes::Tuple, ambient_parameters::AbstractVector{<:Real}, kernel_parameters::AbstractVector{<:Real})
Applies a Gaussian smoothing filter to the ambient parameters (with dimension equaling that of the probability vector).
The gaussian kernel used has variance specified by kernel_parameters[1]^2.
The only difference to the above function is the reshaping function used.
TODO: These being two different functions is a bit ugly, should be fixed.
"""
function fubar_apply_smoothing(grid_sizes::Tuple, codon_param_index_vec::Vector{Vector{Int64}}, ambient_parameters::AbstractVector{<:Real}, kernel_parameters::AbstractVector{<:Real})
    ambient_parameter_array = reshape_probability_vector(grid_sizes, codon_param_index_vec, ambient_parameters)
    kernel = gaussian_kernel(7, kernel_parameters[1]^2) #approximate_gaussian_kernel(kernel_parameters[1]^2, 4)
    smoothed_parameter_array = apply_separable_convolution(ambient_parameter_array, kernel)
    return unreshape_probability_vector(codon_param_index_vec, smoothed_parameter_array)
end

"""
# gaussian_kernel(window_size::Int64, variance::Real)
Generates a 1D Gaussian kernel for convolution.
"""
function gaussian_kernel(window_size::Int64, variance::Real)
    # window_size should be odd for symmetry, but not mandatory
    radius = (window_size - 1) รท 2
    x = -radius:radius                  # symmetric points centered at zero
    kernel = exp.(-(x .^ 2) ./ (2 * variance))  # element-wise Gaussian formula
    kernel /= sqrt(sum(kernel .^ 2))               # This is to make the variance not depend on smoothing TODO: But on the edges this is a bit of a problem?
    return kernel
end

"""
# apply_separable_convolution(x::AbstractArray{<:Real}, kernel::AbstractVector{<:Real})
Applies a separable convolution defined by kernel to a multi-dimensional array x.
"""
function apply_separable_convolution(x::AbstractArray{<:Real}, kernel::AbstractVector{<:Real})
    y = copy(x) # Zygote does not like mutation
    for d in 1:ndims(x)
        y = convolve_along_dim(y, kernel, d)
    end
    return y
end

"""
# convolve_along_dim(x::AbstractArray{<:Real}, kernel::AbstractVector{<:Real}, dim::Int)
Convolves the array x with the kernel along the specified dimension dim.
"""
function convolve_along_dim(x::AbstractArray{<:Real}, kernel::AbstractVector{<:Real}, dim::Int)
    perm = (dim, filter(d -> d != dim, 1:ndims(x))...)
    x_perm = permutedims(x, perm)
    sz = size(x_perm)
    reshaped = reshape(x_perm, sz[1], :)
    #result = map(col -> same_conv(col, kernel), eachcol(reshaped))
    result = map(col -> same_conv(col, kernel), eachcol(reshaped))
    result_mat = hcat(result...)
    result_array = reshape(result_mat, sz...)
    return permutedims(result_array, invperm(perm))
end

"""
# conv_pure(x::AbstractVector{<:Real}, kernel::AbstractVector{<:Real})
Applies a 1D convolution to the input vector x using the specified kernel.
"""
function conv_pure(x::AbstractVector{<:Real}, kernel::AbstractVector{<:Real})
    nx = length(x)
    nk = length(kernel)
    ny = nx - nk + 1
    return [sum(x[i:i+nk-1] .* kernel) for i in 1:ny]
end

"""
# same_conv(col::AbstractVector{<:Real}, kernel::AbstractVector{<:Real})
Applies a 1D convolution to the input vector col using the specified kernel, padding with zeros.
"""
function same_conv(col, kernel)
    klen = length(kernel)
    left = fld(klen - 1, 2)
    right = cld(klen - 1, 2)
    # Padding behaviour is encoded here.
    # Different padding behaviour has different interpretation
    # TODO: What is the best behaviour when padding? A bit of a cursed solution would be to pad with more theta values.
    #padded = vcat(zeros(left) .+ col[1], col, zeros(right) .+ col[end]) # Padding with edge values makes sense here I think, because our best guess at the values directly outside of the grid should be the values at the edge of the grid.
    #padded = vcat(reverse(col[2:left+1]), col, reverse(col[end-right:end-1])) # Mirror
    padded = vcat(zeros(left), col, zeros(right)) # Padding with zeros, may be good.
    conv_result = conv_pure(padded, kernel)
    return conv_result
end